The method used to transform the program from resumption to fixup routines was to pass FixupFunctor's on the stack. FixupFunctor implementations were made for the functions f, g, and main. For f and g, the body of their "catch" blocks was put into their respective FixupFunctor.do_fixup routines.
When f or g are called, they create a new instance of their FixupFunctor implementation on the stack. Each of their functors holds a reference to the functor that the method was originally called with. This causes the FixupFunctors to form a singly linked list, terminted by main's FixupFunctor. This list is analagous to the stack of resumable exceptions in uC++.
When a fixup is required, the function asking for the fixup can either call its local FixupFunctor, or the parent FixupFunctor a passed to it as a parameter. Since the fixup routines cause mutual recursion between f and g, the FixupFunctor.do_fixup functions will always pass the next FixupFunctor in the list to calls to either f or g.
When a fixup routine calls f or g, it is actually branching the list of FixupFunctors, but because the list is linked down towards main's FixupFunctor, this branching doesn't affect the state of the FixupFunctor list being used in the branch ahead of it (or the normal thread of execution, in the base case).
